<script src="/tinytest_dom_edition.js"></script>
<script>
/** 
Purpose:
  The concat() method is used to merge two or more arrays and/or values. 
  This method does not change the existing arrays, but instead returns a new array.

Syntax:
  concat(originalArray, arrayToConcat, valueToConcat);
  
Parameters:
  1) value (Optional)
    Arrays and/or values to concatenate into a new array. 
    If value is undefined, concat returns a shallow copy of the existing array on which it is called.
    Value can be an array, string, null, undefined, boolean value or number.
    If value === array, the array can contain empty values.
    
Return value:
  A new array.

Example 1:
  The following code concatenates two arrays::
  var array1 = ['a', 'b', 'c'];
  var array2 = ['d', 'e', 'f'];

  console.log(concat(array1, array2));
  // expected output: Array ["a", "b", "c", "d", "e", "f"]

Example 2:
  The following code concatenates nested arrays and demonstrates retention of references:

  const num1 = [[1]];
  const num2 = [2, [3]];

  const numbers = concat(num1, num2);

  console.log(numbers);
  // results in [[1], 2, [3]]

  // modify the first element of num1
  num1[0].push(4);

  console.log(numbers);
  // results in [[1, 4], 2, [3]]
**/
  
  function findIndex(array, callback, optionalThis) {
    let callbackWithThis;
    let length;
    let callbackResults;
    let results;
    
    //error generation
    if (typeof(array) === 'boolean' || Number.isNaN(array) || array === null || typeof(array) === 'string' || typeof(array) === 'undefined') {
      try {
        throw new TypeError();
      } catch (e) {
        return 'Uncaught TypeError: customFind(' + array + ') is not a function'
      }
    } 
    
    //error generation
    if (typeof(array) === 'number') {
      try {
        throw new TypeError(); 
      } catch (e) {
        return 'Uncaught SyntaxError: Invalid or unexpected token' 
      }
    }
      
    //optionalThis or default value
    if (optionalThis) {
      callbackWithThis = callback.bind(optionalThis);
    } else {
      callbackWithThis = callback.bind(undefined); 
    }
    
    length = array.length;
    //duplicate .find() logic
    for (let i = 0; i < length; i++) {
      if (Array.isArray(array[i])) {
        continue
      }
      callbackResults = callbackWithThis(array[i], i, array);
      if (callbackResults === true) {
        return i;
      }
    }
    
    //if no results return -1
    return -1
  }
  
  //used for tests
  function isLargeNumber(element) {
    return element > 13;
  }
 
  tests({
    'it returns the index of the first element where the callback returns true': function() {
      let array1 = [5, 12, 8, 130, 44];
      eq(findIndex(array1, isLargeNumber), 3);
    },
    
    'Otherwise, it returns -1, indicating no element passed the test.': function() {
      let array1 = [5];
      eq(findIndex(array1, isLargeNumber), -1);
    },
    
    'callback is invoked with 3 arguments: The value of the element': function() {
      let results = [];
      let array = [1, 2, 1];
      findIndex(array, function(value, index, array) { results.push(value); });
      
      eq(results[0], 1);
      eq(results[1], 2);
      eq(results[2], 1);
    },
    
    'callback is invoked with 3 arguments: The index of the element': function() {
      let results = [];
      let array = [1, 2, 1];
      findIndex(array, function(value, index, array) { results.push(index); });
      
      eq(results[0], 0);
      eq(results[1], 1);
      eq(results[2], 2);
    },
    
    'callback is invoked with 3 arguments: The Array object being traversed': function() {
      let results = [];
      let array = [1, 2, 1];
      findIndex(array, function(value, index, array) { if (results.length === 0) { results = array; } });
      
      eq(results[0], 1);
      eq(results[1], 2);
      eq(results[2], 1);
    },
    
    'callback is called even for indexes of entries not present in the array.': function() {
      let results = [];
      findIndex([1, , 1], function(number) { results.push(number) });
      eq(results.length, 3);
    },
    
    'If a thisArg parameter is provided, it will be used as the this inside each invocation of the callback.': function() {
      findIndex([1], function () {
        eq(this.description, 'I am a configurable this object');
      }, {description: 'I am a configurable this object'});
    },
    
    'If it is not provided, then undefined is used.': function() {
      findIndex([1], function () {
        eq(this.description, undefined);
      });
    },
    
    'it does not mutate the array on which it is called.': function() {
      let array1 = [1, 2];
      findIndex(array1, isLargeNumber);
      eq(array1[0], 1);
      eq(array1[1], 2);
    },
    
    'The range of elements processed is set before the first invocation of callback.': function() {
      let array1 = [1, 2];
      eq(findIndex(array1, function(number) { array1.push(500); return number > 13; }), -1);
    },
    
    'If an existing, unvisited element of the array is changed by callback, its value passed to the visiting callback will be the value at the time that find visits that element\'s index': function() {
      let array1 = [1, 2];
      eq(findIndex(array1, function(number) { array1[1] = 500; return number > 13; }), 1);
    },
    
    'elements that are deleted are still visited.': function() {
      let results = []
      let array = [1, 2, 1];
      findIndex(array, function(number) { delete array[2]; results.push(number); });
      
      eq(results[2], undefined);
    },
    
    'Finds an object in an array by one of its properties': function() {
      let array = [
        {name: 'apples', quantity: 2},
        {name: 'bananas', quantity: 0},
        {name: 'cherries', quantity: 5}
      ];
      let results = findIndex(array, function(array) { return array.quantity === 2 })
      eq(results, 0);
    },
  });
</script>